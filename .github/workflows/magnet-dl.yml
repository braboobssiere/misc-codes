name: Magnet Downloader
on:
  workflow_dispatch:
    inputs:
      source:
        description: "Input link"
        required: true
        type: string
      file_name:
        description: "Optional: File name to download (leave empty for all files)"
        required: false
        type: string
        default: ""

jobs:
  process-downloader:
    runs-on: ubuntu-latest
    steps:

      - name: Set monthly cache key
        id: monthly-key
        run: |
          MONTH=$(date +"%Y.%m")
          echo "month=${MONTH}" >> $GITHUB_OUTPUT

      - name: Cache APT packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: wireguard-tools lftp
          version: ${{ steps.monthly-key.outputs.month }}

      - name: Maximize space
        uses: easimon/maximize-build-space@v10
        with:
          swap-size-mb: 10240

      - name: Install Dependency 
        run: |
          sudo apt-get update
          sudo apt-get install -y wireguard-tools lftp
          sudo npm install webtorrent-cli -g

      - name: VPN Setup 
        env: 
          PRIMARY_CONFIG: ${{ secrets.WIREGUARD_GRANDCENTRAL }}
          SECONDARY_CONFIG: ${{ secrets.WIREGUARD_TRADEWAR }}
          
        run: |
          sudo mkdir -p /etc/wireguard/
          WG_CONF="/etc/wireguard/wg0.conf"
          handle_vpn_attempt() {
            local config_content="$1"
            local label="$2"
            
            echo "$config_content" | sudo tee $WG_CONF > /dev/null
            sudo chmod 600 $WG_CONF

            for i in {1..3}; do
              if timeout 60 sudo wg-quick up wg0; then
                return 0
              fi
              echo "${label^} VPN attempt $i/3 failed"
              sleep 3
            done
            return 1
          }
          if ! handle_vpn_attempt "$PRIMARY_CONFIG" "primary"; then
            echo "::warning::Primary failed - Trying secondary"
            if ! handle_vpn_attempt "$SECONDARY_CONFIG" "secondary"; then
              echo "::error::All VPN configurations failed after 3 attempts each"
              exit 11
            fi
          fi
          if ! sudo wg show wg0 >/dev/null 2>&1; then
            echo "::error::VPN connection verification failed"
            exit 12
          fi
        
      - name: Download files
        id: download-files
        run: |
          mkdir -p magnet_output
          
          # Check if file_name is provided
          if [ -n "${{ github.event.inputs.file_name }}" ]; then
            echo "File name specified: ${{ github.event.inputs.file_name }}"
            echo "Listing torrent files to find closest match..."
            
            # First, list all files without downloading
            torrent_list=$(webtorrent download "${{ github.event.inputs.source }}" --select 2>&1 | grep -E '^\s*[0-9]+\s+' || true)
            
            if [ -z "$torrent_list" ]; then
              echo "Could not list torrent files. Falling back to download all files."
              webtorrent download "${{ github.event.inputs.source }}" --out magnet_output
            else
              # Parse the output to find file indices and names
              echo "Available files in torrent:"
              echo "$torrent_list"
              
              # Find the file index with closest name match
              selected_index=""
              best_score=0
              
              # Convert input to lowercase for case-insensitive comparison
              input_lower=$(echo "${{ github.event.inputs.file_name }}" | tr '[:upper:]' '[:lower:]')
              
              while IFS= read -r line; do
                # Extract index and filename from the line
                index=$(echo "$line" | sed -E 's/^\s*([0-9]+)\s+.*/\1/')
                filename=$(echo "$line" | sed -E 's/^\s*[0-9]+\s+//' | sed -E 's/\s+\(.*$//')
                
                if [ -n "$index" ] && [ -n "$filename" ]; then
                  # Convert filename to lowercase for case-insensitive matching
                  filename_lower=$(echo "$filename" | tr '[:upper:]' '[:lower:]')
                  
                  # Calculate similarity score
                  score=0
                  
                  # Check for exact case match first (highest priority)
                  if [[ "$filename" == *"${{ github.event.inputs.file_name }}"* ]]; then
                    # Exact case match gets a high base score
                    score=1000
                    # Add length bonus - longer matching substring is better
                    score=$((score + ${#filename}))
                    echo "  Found exact case match: $filename (score: $score)"
                  # Check for case-insensitive match
                  elif [[ "$filename_lower" == *"$input_lower"* ]]; then
                    # Case-insensitive match gets lower base score
                    score=500
                    # Add length bonus
                    score=$((score + ${#filename}))
                    echo "  Found case-insensitive match: $filename (score: $score)"
                  fi
                  
                  # If we have a match and it's the best score so far
                  if [ $score -gt $best_score ]; then
                    best_score=$score
                    selected_index=$index
                  fi
                fi
              done <<< "$torrent_list"
              
              if [ -n "$selected_index" ]; then
                echo "Selected file index: $selected_index (best score: $best_score)"
                webtorrent download "${{ github.event.inputs.source }}" --select "$selected_index" --out magnet_output
              else
                echo "No matching file found. Downloading all files."
                webtorrent download "${{ github.event.inputs.source }}" --out magnet_output
              fi
            fi
          else
            echo "No file name specified. Downloading all files."
            webtorrent download "${{ github.event.inputs.source }}" --out magnet_output
          fi
          
          # Get the downloaded file name(s)
          download_output=$(webtorrent download "${{ github.event.inputs.source }}" --out magnet_output 2>&1 | tail -20 || true)
          files_name=$(echo "$download_output" | grep -oP '(?<=Downloading: ).*' | head -n 1)
          if [ -z "$files_name" ]; then
            # Try to get file name from directory
            if [ -d "magnet_output" ]; then
              files_name=$(ls magnet_output/ 2>/dev/null | head -n 1)
            fi
          fi
          echo "files_name=${files_name}" >> $GITHUB_ENV

      - name: VPN Cleanup
        if: ${{ always() }}
        run: sudo wg-quick down wg0 || true
        
      - name: Prepare files for FTP upload
        id: prepare-ftp
        run: |
          mkdir -p ftp_upload
          find magnet_output -type f \( -name "*.mp4" -o -name "*.mkv" -o -name "*.ts" -o -name "*.webm" \) \
            -exec mv -- {} ftp_upload/ \;
          
          if [ "$(ls -A ftp_upload)" ]; then
            echo "has_files=true" >> $GITHUB_OUTPUT
            echo "Files found in ftp_upload directory"
          else
            echo "has_files=false" >> $GITHUB_OUTPUT
            echo "No files found. Skipping FTP upload."
          fi

      - name: Upload to FTP (Server 1)
        if: steps.prepare-ftp.outputs.has_files == 'true'
        run: |
          lftp -u ${{ secrets.FTP_LOGIN }} -e "
            set ssl:verify-certificate false;
            set cache:size 524288000;
            mput -P 1 ftp_upload/*;
            bye"
          echo "ftp upload 1 done"

      - name: Upload to FTP (Server 2)
        if: steps.prepare-ftp.outputs.has_files == 'true'
        run: |
          lftp -u ${{ secrets.FTP_LOGIN_ARCHIVE }} -e "
            set ssl:verify-certificate false;
            set cache:size 524288000;
            mput -P 1 ftp_upload/*;
            bye"
          echo "ftp upload 2 done"
          
      - name: Zip files 
        run: |
          cd magnet_output
          if [ -n "$(find . -type f)" ]; then
            zip -0 -r -m -s 2g "${{ env.files_name }}.zip" .
          else
            echo "Skipping zip: No non-video files found"
          fi
        shell: bash

      - name: Upload Files to Gofile
        run: |
          if [ -z "$(find magnet_output -type f -print -quit)" ]; then
            echo "Skipping GoFile upload: No files to upload"
            exit 0
          fi
          
          UPLOAD_URL="https://upload.gofile.io/uploadfile"
          guest_token=""
          folder_id=""
          UPLOAD_LINKS=""
          FIRST_FILE=true

          while IFS= read -r -d '' file; do
            echo "Starting upload: $(basename "$file")"
            extra_args=()
            if [ "$FIRST_FILE" = false ]; then
              extra_args+=(-H "Authorization: Bearer $guest_token" -F "folderId=$folder_id")
            fi
            
            RESPONSE=$(curl -s -X POST -F "file=@\"$file\"" "${extra_args[@]}" "$UPLOAD_URL")

            PYTHON_OUTPUT=$(python3 <<EOF
          import json, sys
          try:
              data = json.loads('''$RESPONSE''')
              if "$FIRST_FILE" == "true":
                  guest_token = data['data']['guestToken']
                  folder_id = data['data']['parentFolder']
                  print(f"{guest_token}\t{folder_id}")
              else:
                  print("-\t-")          
              status = 'ok' if data['status'] == 'ok' else 'error'
              result_data = data.get('data', {}).get('downloadPage', '') if status == 'ok' else data.get('data', '')
              print(f"{status}\t{result_data}")
          except Exception as e:
              print(f"error\tJSON parsing failed: {str(e)}")
              sys.exit(1)
          EOF
            )

            {
              read -r token_part folder_part
              read -r status_type result_data
            } <<< "$PYTHON_OUTPUT"

            if [ "$FIRST_FILE" = true ]; then
              guest_token="$token_part"
              folder_id="$folder_part"
              FIRST_FILE=false
              echo "GUEST_TOKEN=$guest_token" >> $GITHUB_ENV
              echo "FOLDER_ID=$folder_id" >> $GITHUB_ENV
              echo "Created folder ID"
            fi

            if [ "$status_type" != "ok" ]; then
              echo "::error file=$file::Upload failed: $result_data"
            else
              LINK="$result_data"
              UPLOAD_LINKS+="- $(basename "$file")\n"
              echo "Success: $LINK"
            fi
          done < <(find magnet_output/ -type f -print0)

          echo -e "### File Uploads: \n$LINK \n$UPLOAD_LINKS" >> $GITHUB_STEP_SUMMARY

          curl -X POST \
            -H "Content-Type: application/json" \
            -d "{\"content\":\"File Uploads: \n${{ env.buzz_url }} \n$LINK \n$UPLOAD_LINKS\"}" \
            "${{ secrets.DISCORD_WEBHOOK }}"
