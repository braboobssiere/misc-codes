name: Song Recognition
on: workflow_dispatch

jobs:
  recognize:
    runs-on: ubuntu-latest
    outputs:
      results: ${{ steps.songrec.outputs.responses }}
    steps:
    
    - name: Checkout code
      uses: actions/checkout@v4  # Get repository contents

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y software-properties-common ffmpeg jq
        
        wget -qO- 'http://keyserver.ubuntu.com/pks/lookup?op=get&search=0x6888550b2fc77d09' | sudo tee /etc/apt/trusted.gpg.d/songrec.asc
        sudo add-apt-repository ppa:marin-m/songrec -y
        sudo apt-get install -y songrec
        
    - name: Process audio files
      id: songrec
      run: |
        cd input/songrec
        :> entries.json  # Initialize JSON storage
        
        # Process files in directory
        for file in *; do

            # Skip metadata files
            [[ "$file" == entries.json || "$file" == output.json ]] && continue
            
            # Detect file type
            mime_type=$(file --mime-type -b "$file")
            has_audio=false
            
            # Audio/video handling
            if [[ $mime_type == audio/* ]]; then
                has_audio=true
            elif [[ $mime_type == video/* ]]; then
                # Check for audio streams
                ffmpeg -nostdin -i "$file" -hide_banner 2>&1 | grep -qi 'audio' && has_audio=true
            else
                # Skip unsupported formats
                echo "::notice:: Skipping non-media file: $file (MIME: $mime_type)"
                continue
            fi
            
            [[ $has_audio != true ]] && continue  # No audio content

            # Attempt recognition with error fallback
            response=$(songrec audio-file-to-recognized-song "$file" 2>&1 || echo '{"error":"no_match"}')
            
            # Validate JSON structure
            if ! jq -e . >/dev/null 2>&1 <<< "$response"; then
                response='{"error":"invalid_response"}'
            fi
            
            # Extract URL or error message
            url=$(jq -r '
                if .error? then
                    "❌ Error: " + (.error | tostring)
                elif .track?.url? then
                    .track.url
                else
                    "❌ No match found"
                end' <<< "$response" 2>/dev/null || echo "🛑 Processing error")
            
            # Write to workflow summary
            echo "### \`$file\`" >> $GITHUB_STEP_SUMMARY
            echo "**Track URL**: ${url}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Build structured JSON output
            jq -n \
                --arg fn "$file" \
                --arg url "$url" \
                '{file: $fn, url: $url}' >> entries.json
        done
        
        # Finalize outputs
        if [ -s entries.json ]; then
            jq -s '{responses: .}' entries.json > output.json  # Combine entries
            echo "results=$(jq -c . output.json)" >> $GITHUB_OUTPUT
        else
            echo "⚠️ No processable files found" >> $GITHUB_STEP_SUMMARY
            echo "results=[]" >> $GITHUB_OUTPUT
        fi
        rm -f entries.json output.json  # Cleanup
