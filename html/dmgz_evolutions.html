<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Digimon Evolution Path Finder</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 18px; background:#f6f8fa; color:#111;}
    h1 { margin-top:0; }
    .row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
    .control { background:white; padding:10px;border-radius:8px; box-shadow:0 1px 4px rgba(0,0,0,0.05); }
    label { margin-right:8px; font-weight:600; }
    select, button { padding:6px 8px; font-size:14px; }
    .paths { white-space:pre-wrap; background:#fff; padding:12px; border-radius:8px; margin-top:12px; box-shadow:0 1px 4px rgba(0,0,0,0.05); }
    .alt { margin-left:8px; color:#333; }
    .small { font-size:13px; color:#555; }
    .muted { color:#666; font-size:13px; }
    .chip { padding:6px 8px; border-radius:999px; background:#eef3ff; color:#133; display:inline-block; margin-right:6px; font-weight:600; }
  </style>
</head>
<body>
  <h1>Digimon Evolution Path Finder</h1>
  
  <div class="row control">
    <div>
      <label>Area 7</label>
      <label><input type="radio" name="area7" value="yes" checked> Yes</label>
      <label><input type="radio" name="area7" value="no"> No</label>
    </div>

    <div>
      <label>G-Cell</label>
      <label><input type="radio" name="gcell" value="yes" checked> Yes</label>
      <label><input type="radio" name="gcell" value="no"> No</label>
    </div>

    <div style="margin-left:auto;">
      <button id="refreshBtn">Refresh lists</button>
    </div>
  </div>

  <div class="row control">
    <div>
      <label>Start Digimon</label><br/>
      <select id="startSelect" style="min-width:220px;"></select>
      <div class="small muted">Only digimon that can evolve further under current Area7/G-Cell choices.</div>
    </div>

    <div>
      <label>Target Digimon</label><br/>
      <select id="targetSelect" style="min-width:240px;"></select>
      <div class="small muted">Final reachable forms. Choose <b>Random</b> to hide names in paths (shows "???").</div>
    </div>

    <div style="align-self:flex-end;">
      <button id="showPaths">Show paths</button>
    </div>
  </div>

  <div class="control">
    <div id="summary" class="small"></div>
    <div id="paths" class="paths"></div>
  </div>

<script>
(async function(){
  const DATA_URL = 'dmgz_evolutions.json';
  let data = {};
  try {
    const r = await fetch(DATA_URL);
    if (!r.ok) throw new Error('Failed to fetch ' + DATA_URL + ' (status ' + r.status + ')');
    data = await r.json();
  } catch (e) {
    document.getElementById('paths').textContent = 'Error loading data: ' + e.message + '\nMake sure dmgz_evolutions.json is in the same folder as this HTML file.';
    return;
  }

  function allowedValuesFromChoice(choice) { return choice === 'yes' ? [true, 'Any'] : [false, 'Any']; }
  function condMatchesGArea(cond, allowedG, allowedA) {
    const g = cond['G-Cell'], a = cond['area7'];
    return (g==='Any'||allowedG.includes(g)) && (a==='Any'||allowedA.includes(a));
  }
  function edgeAllowed(evo, allowedG, allowedA) { return evo.conditions.some(c => condMatchesGArea(c, allowedG, allowedA)); }

  const digimonNames = Object.keys(data).sort((a,b)=>a.localeCompare(b));
  const startSelect = document.getElementById('startSelect');
  const targetSelect = document.getElementById('targetSelect');
  const refreshBtn = document.getElementById('refreshBtn');
  const showBtn = document.getElementById('showPaths');
  const pathsEl = document.getElementById('paths');
  const summaryEl = document.getElementById('summary');

  function readChoice(name) {
    const radios = document.getElementsByName(name);
    for (const r of radios) if (r.checked) return r.value;
    return 'yes';
  }

  function reachableFrom(start, allowedG, allowedA) {
    const visited = new Set(), finalTargets = new Set(), stack = [start];
    visited.add(start);
    while(stack.length){
      const node = stack.pop();
      const evos = data[node]?.evolutions || [];
      let hadAllowedChild = false;
      for(const evo of evos){
        if(edgeAllowed(evo, allowedG, allowedA)){
          hadAllowedChild = true;
          if(!visited.has(evo.to)) { visited.add(evo.to); stack.push(evo.to); }
        }
      }
      if(!hadAllowedChild) finalTargets.add(node);
    }
    return { visited, finals: finalTargets };
  }

  function computeStartOptions(allowedG, allowedA) {
    const options = [];
    for(const name of digimonNames){
      const nodeEvos = data[name]?.evolutions||[];
      if(nodeEvos.some(e=>edgeAllowed(e, allowedG, allowedA))) options.push(name);
    }
    return options.sort((a,b)=>a.localeCompare(b));
  }

  function computeFinalTargetsForStart(start, allowedG, allowedA){
    const res = reachableFrom(start, allowedG, allowedA);
    return Array.from(res.finals).sort((a,b)=>a.localeCompare(b));
  }

  function condToReadable(c){
    const parts=[];
    if(c['G-Cell']!=='Any') parts.push(c['G-Cell']===true?'Hatched from a G-Cell Fragment':'Not hatched from a G-Cell Fragment');
    if(c['area7']!=='Any') parts.push(c['area7']===true?'Clear Area 7':'Not clear Area 7');
    if(c['mistake'] && c['mistake']!=='Any') parts.push('Care Mistakes ' + (c['mistake'].endsWith('-0')?c['mistake'].split('-')[0]+'+':c['mistake']));
    if(c['color'] && c['color']!=='Any'){ const m=c['color'].match(/^([rby])(.+)$/i); if(m){const letter=m[1].toLowerCase(),nums=m[2],colorName=letter==='r'?'Red':letter==='b'?'Blue':'Yellow'; parts.push(nums.endsWith('-0')?`${colorName} G-cells ${nums.split('-')[0]}+`:`${colorName} G-cells ${nums}`);} else parts.push('Color '+c['color']); }
    if(c['battle']!=='Any') parts.push(c['battle']===true?'Need Battles':'No Battles');
    return parts.join(', ');
  }

  function matchingConditionsForEdge(evo, allowedG, allowedA){
    return evo.conditions.filter(c=>condMatchesGArea(c, allowedG, allowedA)).map(c=>({raw:c,text:condToReadable(c)}));
  }

  function findAllPaths(start, target, allowedG, allowedA){
    const results=[];
    const visited=new Set();
    function dfs(node,path){
      if(path.length>40) return;
      if(node===target){ results.push([...path]); return; }
      visited.add(node);
      const evos=data[node]?.evolutions||[];
      for(const evo of evos){
        if(!edgeAllowed(evo, allowedG, allowedA)) continue;
        const child=evo.to;
        if(visited.has(child)) continue;
        path.push({from:node,to:child,evo});
        dfs(child,path);
        path.pop();
      }
      visited.delete(node);
    }
    dfs(start,[]);
    return results;
  }

  function populateStartAndTargets(){
    const areaChoice=readChoice('area7'), gcellChoice=readChoice('gcell');
    const allowedG=allowedValuesFromChoice(gcellChoice), allowedA=allowedValuesFromChoice(areaChoice);
    const starts=computeStartOptions(allowedG, allowedA);
    startSelect.innerHTML=''; const startPlaceholder=document.createElement('option'); startPlaceholder.value=''; startPlaceholder.textContent='-- Select start --'; startSelect.appendChild(startPlaceholder);
    for(const s of starts){ const o=document.createElement('option'); o.value=s; o.textContent=s; startSelect.appendChild(o); }
    targetSelect.innerHTML=''; const opt=document.createElement('option'); opt.value=''; opt.textContent='-- Select target --'; targetSelect.appendChild(opt); targetSelect.disabled=true;
    summaryEl.textContent=`Area7: ${areaChoice==='yes'?'Yes (allow true & Any)':'No (allow false & Any)'}; G-Cell: ${gcellChoice==='yes'?'Yes (allow true & Any)':'No (allow false & Any)'}`;
    pathsEl.textContent='';
  }

  startSelect.addEventListener('change',()=>{
    const start=startSelect.value;
    targetSelect.innerHTML='';
    if(!start){ targetSelect.disabled=true; return; }
    const areaChoice=readChoice('area7'), gcellChoice=readChoice('gcell');
    const allowedG=allowedValuesFromChoice(gcellChoice), allowedA=allowedValuesFromChoice(areaChoice);
    const finals=computeFinalTargetsForStart(start, allowedG, allowedA);
    targetSelect.disabled=false;
    const rand=document.createElement('option'); rand.value='__RANDOM__'; rand.textContent='Random (mask species names)'; targetSelect.appendChild(rand);
    for(const f of finals){ const o=document.createElement('option'); o.value=f; o.textContent=f; targetSelect.appendChild(o); }
    if(finals.length===0){ targetSelect.innerHTML=''; const o=document.createElement('option'); o.value=''; o.textContent='-- No reachable final targets --'; targetSelect.appendChild(o); targetSelect.disabled=true; }
    pathsEl.textContent='';
  });

  refreshBtn.addEventListener('click',()=>{ populateStartAndTargets(); });

  showBtn.addEventListener('click',()=>{
    const start=startSelect.value, targetVal=targetSelect.value;
    if(!start){ pathsEl.textContent='Please select a Start Digimon.'; return; }
    if(!targetVal){ pathsEl.textContent='Please select a Target Digimon (or Random).'; return; }
    const areaChoice=readChoice('area7'), gcellChoice=readChoice('gcell');
    const allowedG=allowedValuesFromChoice(gcellChoice), allowedA=allowedValuesFromChoice(areaChoice);
    const finals=computeFinalTargetsForStart(start, allowedG, allowedA);
    if(finals.length===0){ pathsEl.textContent='No reachable final targets from selected start under current Area7/G-Cell settings.'; return; }

    let chosenTarget=targetVal;
    const isRandom=targetVal==='__RANDOM__';
    if(isRandom) chosenTarget=finals[Math.floor(Math.random()*finals.length)];
    const allPaths=findAllPaths(start, chosenTarget, allowedG, allowedA);
    if(allPaths.length===0){ pathsEl.textContent=start===chosenTarget?`Start is already the final form (${start}). No evolution steps.`:'No valid paths found from start to target under current settings.'; return; }

    pathsEl.innerHTML='';
    const summaryDiv=document.createElement('div'); summaryDiv.textContent=`Start: ${start}, Target: ${isRandom?'Random (masked)':chosenTarget}, Paths found: ${allPaths.length}`; summaryDiv.style.marginBottom='12px'; pathsEl.appendChild(summaryDiv);

    allPaths.forEach((path,idx)=>{
      const pathDiv=document.createElement('div'); pathDiv.style.marginBottom='16px'; pathDiv.style.padding='8px'; pathDiv.style.border='1px solid #ddd'; pathDiv.style.borderRadius='8px'; pathDiv.style.background='#fafafa';
      const speciesLine=[start,...path.map(step=>step.to)];
      const displaySpecies=speciesLine.map((s,i)=>isRandom&&i!==0?'???':s);
      let pathText=`Path ${idx+1}: ${displaySpecies.join(' -> ')}\n`;
      path.forEach((step,i)=>{
        const matches=matchingConditionsForEdge(step.evo,allowedG,allowedA);
        pathText+=`  Step ${i+1}: ${isRandom?'???':step.from} -> ${isRandom?'???':step.to}\n`;
        if(matches.length===0) pathText+='    (No specific conditions to show)\n';
        else matches.forEach(m=>{ const text=m.text||'(no special conditions)'; pathText+=`    - ${text}\n`; });
      });
      const pre=document.createElement('pre'); pre.textContent=pathText; pathDiv.appendChild(pre);
      const copyBtn=document.createElement('button'); copyBtn.textContent='Copy'; copyBtn.style.marginTop='4px'; copyBtn.style.padding='4px 8px'; copyBtn.style.fontSize='13px';
      copyBtn.addEventListener('click',()=>{ navigator.clipboard.writeText(pathText).then(()=>{ copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',1000); }); });
      pathDiv.appendChild(copyBtn);
      pathsEl.appendChild(pathDiv);
    });
  });

  populateStartAndTargets();
  if(startSelect.options.length===2){ startSelect.selectedIndex=1; startSelect.dispatchEvent(new Event('change')); }
})();
</script>
</body>
</html>
