<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCGPlayer Text to YDK Converter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        textarea {
            width: 100%;
            height: 200px;
        }
        button {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>TCGPlayer Text to YDK Converter</h1>
    <form id="converterForm">
        <label for="fileInput">Select TCGPlayer text file:</label>
        <input type="file" id="fileInput" accept=".txt">
        <br><br>
        <label for="textInput">Or enter TCGPlayer text content:</label>
        <textarea id="textInput" placeholder="3 Tenpai Dragon Paidra&#10;3 Tenpai Dragon Chundra&#10;2 Tenpai Dragon Fadra&#10;&#10;1 Black Rose Dragon&#10;1 Odd-Eyes Meteorburst Dragon&#10;1 Promethean Princess, Bestower of Flames&#10;&#10;1 Koa'ki Meiru Drago&#10;1 Bystial Druiswurm"></textarea>
        <br>
        <button type="submit">Convert to YDK</button>
    </form>
    <div id="downloadLinkContainer" style="display:none;">
        <a id="downloadLink" href="#" download="deck.ydk">Download YDK File</a>
    </div>
    <div id="logDownloadContainer" style="display:none;">
        <a id="logDownloadLink" href="#" download="error_log.txt">Download Error Log</a>
    </div>

    <script>
        let errorLog = '';

        function logError(message) {
            errorLog += message + '\n';
        }

        document.getElementById('converterForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const fileInput = document.getElementById('fileInput');
            const textInput = document.getElementById('textInput').value.trim();
            let inputText = '';

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = async (event) => {
                    inputText = event.target.result;
                    await processInput(inputText);
                };
                reader.readAsText(file);
            } else if (textInput) {
                inputText = textInput;
                await processInput(inputText);
            } else {
                alert('Please provide either a file or text input.');
                logError('No input provided.');
                downloadLog();
            }
        });

        async function processInput(inputText) {
            const sections = inputText.split(/\n\n+/); // Split on double newlines for old format
            const mainDeck = [];
            const extraDeck = [];
            const sideDeck = [];

            // Check if the input contains the new format headers
            const hasNewFormat = sections.some(section => section.trim().startsWith("Main Deck:") || section.trim().startsWith("Extra Deck:") || section.trim().startsWith("Side Deck:"));

            if (hasNewFormat) {
                // Process new format
                sections.forEach(section => {
                    const lines = section.trim().split('\n').map(line => line.trim()).filter(line => line);
                    if (lines.length > 0) {
                        const header = lines[0];
                        const cards = lines.slice(1); // Get all lines after the header

                        if (header.includes("Main Deck")) {
                            mainDeck.push(...cards);
                        } else if (header.includes("Extra Deck")) {
                            extraDeck.push(...cards);
                        } else if (header.includes("Side Deck")) {
                            sideDeck.push(...cards);
                        }
                    }
                });
            } else {
                // Process old format
                const mainDeckSection = sections[0] ? sections[0].split('\n').map(line => line.trim()).filter(line => line) : [];
                const extraDeckSection = sections[1] ? sections[1].split('\n').map(line => line.trim()).filter(line => line) : [];
                const sideDeckSection = sections[2] ? sections[2].split('\n').map(line => line.trim()).filter(line => line) : [];

                mainDeck.push(...mainDeckSection);
                extraDeck.push(...extraDeckSection);
                sideDeck.push(...sideDeckSection);
            }

            const cardRequests = [
                ...mainDeck.map(line => {
                    const [quantity, ...cardNameParts] = line.split(' x');
                    return { quantity: parseInt(quantity), cardName: cardNameParts.join(' x'), type: 'main' };
                }),
                ...extraDeck.map(line => {
                    const [quantity, ...cardNameParts] = line.split(' x');
                    return { quantity: parseInt(quantity), cardName: cardNameParts.join(' x'), type: 'extra' };
                }),
                ...sideDeck.map(line => {
                    const [quantity, ...cardNameParts] = line.split(' x');
                    return { quantity: parseInt(quantity), cardName: cardNameParts.join(' x'), type: 'side' };
                })
            ];

            const cardNames = cardRequests.map(card => encodeURIComponent(card.cardName)).join('|');
            const apiUrl = `https://db.ygoprodeck.com/api/v7/cardinfo.php?name=${cardNames}`;
            logError(`API Call: ${apiUrl}`); // Log the API call

            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                logError(`API Response: ${JSON.stringify(data)}`); // Log the API response

                // Check for errors in the response
                if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                    const ydkContent = generateYdkContent(data.data, cardRequests);
                    createDownloadLink(ydkContent);
                } else {
                    // Log specific error messages if available
                    const errorMessage = data && data.error ? data.error : 'Unknown error occurred.';
                    alert('Error fetching card data: ' + errorMessage);
                    logError('Error fetching card data: ' + errorMessage);
                    downloadLog();
                }
            } catch (error) {
                console.error('Fetch error:', error);
                alert('Error fetching card data. Please try again.');
                logError('Fetch error: ' + error.message);
                downloadLog();
            }
        }

        function generateYdkContent(cardData, cardRequests) {
            const ydkLines = [];
            ydkLines.push("#created by TCGPlayer Text to YDK Converter");

            // Main Deck
            ydkLines.push("#main");
            cardRequests.filter(req => req.type === 'main').forEach(request => {
                const cardInfo = cardData.find(card => card.name === request.cardName);
                if (cardInfo) {
                    for (let i = 0; i < request.quantity; i++) {
                        ydkLines.push(cardInfo.id.toString());
                    }
                } else {
                    logError(`Card not found in main deck: ${request.cardName}`);
                }
            });

            // Extra Deck
            ydkLines.push("#extra");
            cardRequests.filter(req => req.type === 'extra').forEach(request => {
                const cardInfo = cardData.find(card => card.name === request.cardName);
                if (cardInfo) {
                    for (let i = 0; i < request.quantity; i++) {
                        ydkLines.push(cardInfo.id.toString());
                    }
                } else {
                    logError(`Card not found in extra deck: ${request.cardName}`);
                }
            });

            // Side Deck
            ydkLines.push("#side");
            cardRequests.filter(req => req.type === 'side').forEach(request => {
                const cardInfo = cardData.find(card => card.name === request.cardName);
                if (cardInfo) {
                    for (let i = 0; i < request.quantity; i++) {
                        ydkLines.push(cardInfo.id.toString());
                    }
                } else {
                    logError(`Card not found in side deck: ${request.cardName}`);
                }
            });

            return ydkLines.join('\n').trim();
        }

        function createDownloadLink(content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            // Get the current timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); // Format timestamp
            const filename = `deck_${timestamp}.ydk`; // Create filename with timestamp

            const downloadLink = document.getElementById('downloadLink');
            downloadLink.href = url;
            downloadLink.download = filename; // Set the download attribute with the new filename
            document.getElementById('downloadLinkContainer').style.display = 'block';
        }

        function downloadLog() {
            if (errorLog) {
                const logBlob = new Blob([errorLog], { type: 'text/plain' });
                const logUrl = URL.createObjectURL(logBlob);
                const logDownloadLink = document.getElementById('logDownloadLink');
                logDownloadLink.href = logUrl;
                document.getElementById('logDownloadContainer').style.display = 'block';
            }
        }
    </script>
</body>
</html>
